<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Minecraft World Analyzer ‚Äì Full Features</title>
  <style>
    body { font-family: sans-serif; background:#f0f0f0; padding:20px; }
    canvas { border:1px solid #333; cursor:grab; display:block; margin-top:10px; }
    #controls { background:#fff; padding:10px; border:1px solid #ccc; border-radius:6px; max-width:320px; }
    label { display:block; margin:6px 0; }
    #tooltip { position:absolute; background:#fff; border:1px solid #333; padding:5px; display:none; pointer-events:none; font-size:13px; }
  </style>
</head>
<body>
  <h2>üó∫Ô∏è Minecraft World Analyzer (Block‚ÄëLevel, Full Features)</h2>
  <div id="controls">
    <label>Seed: <input type="number" id="seed" value="12345"></label>
    <label>Your X (block): <input type="number" id="playerX" value="0"></label>
    <label>Your Z (block): <input type="number" id="playerZ" value="0"></label>
    <label>Map size (blocks, radius): <input type="number" id="range" value="128"></label>
    <label><input type="checkbox" id="showTerrain" checked> Terrain</label>
    <label><input type="checkbox" id="heightShading" checked> Height shading</label>
    <label><input type="checkbox" id="showSlime" checked> Slime chunks</label>
    <label><input type="checkbox" id="showStructures" checked> Structures</label>
    <label><input type="checkbox" id="showCaves"> Cave preview</label>
    <label><input type="checkbox" id="showGrid"> Show grid</label>
    <button onclick="drawMap()">Generate</button>
    <button onclick="exportMap()">Export PNG</button>
  </div>

  <!-- Map + Legend side by side -->
  <div style="display:flex; gap:20px; align-items:flex-start;">
    <canvas id="map" width="800" height="800"></canvas>
    <div id="legend" style="background:#fff; border:1px solid #ccc; border-radius:6px; padding:10px; max-width:300px;">
      <h3 style="margin:0 0 8px 0;">Legend</h3>
      <div><span style="display:inline-block;width:16px;height:16px;background:#6fbde6;border:1px solid #000;margin-right:6px;"></span>Ocean</div>
      <div><span style="display:inline-block;width:16px;height:16px;background:#f1c36d;border:1px solid #000;margin-right:6px;"></span>Desert</div>
      <div><span style="display:inline-block;width:16px;height:16px;background:#98c77c;border:1px solid #000;margin-right:6px;"></span>Plains</div>
      <div><span style="display:inline-block;width:16px;height:16px;background:#2c7a2c;border:1px solid #000;margin-right:6px;"></span>Forest</div>
      <div><span style="display:inline-block;width:16px;height:16px;background:#00ff00;border:1px solid #000;margin-right:6px;"></span>Slime Chunk</div>
      <div><span style="display:inline-block;width:16px;height:16px;background:#888;border:1px solid #000;margin-right:6px;"></span>Cave Area</div>
      <div>üè† Village</div>
      <div>‚õ©Ô∏è Temple</div>
      <div>‚öîÔ∏è Stronghold</div>
      <div style="color:#ff0000;">‚óè Player</div>
    </div>
  </div>

  <!-- Tooltip element -->
  <div id="tooltip"></div>

<script>
const canvas = document.getElementById('map');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');
let zoom = 1, offsetX=0, offsetZ=0;
let dragging=false, dragStartX=0, dragStartY=0;

// Noise
function noise(x,z,seed){ return Math.sin((x*374761393+z*668265263+seed*982451653)%2147483647)*0.5+0.5; }

// Biomes
function biomeColor(x,z,seed){
  const t=noise(x*0.02,z*0.02,seed), m=noise(x*0.02+100,z*0.02-100,seed);
  if(t<0.3) return [111,189,230]; // ocean
  if(t>0.7 && m<0.4) return [241,195,109]; // desert
  if(m>0.6) return [44,122,44]; // forest
  return [152,199,124]; // plains
}
function shadeColor(rgb,elev,enabled){
  if(!enabled) return rgb;
  const factor=(elev-0.5)*0.8;
  return rgb.map(c=>Math.min(255,Math.max(0,c+factor*128)));
}

// Features
function isSlimeChunk(seed,x,z){
  const cx=Math.floor(x/16), cz=Math.floor(z/16);
  let rnd = BigInt(seed) +
            BigInt(cx)*BigInt(cx)*0x4c1906n +
            BigInt(cx)*0x5ac0dbn +
            BigInt(cz)*BigInt(cz)*0x4307a7n +
            BigInt(cz)*0x5f24fen ^ 0x3ad8025fn;
  rnd = rnd & 0xffffffffn;
  let n = Number(rnd);
  if (n > 0x7fffffff) n -= 0x100000000;
  return (n % 10) === 0;
}
function isVillage(x,z){ return (x%512===0 && z%512===0); }
function isTemple(x,z){ return (x%480===0 && z%480===0); }
function isStronghold(x,z){ let d=Math.sqrt(x*x+z*z); return Math.abs(d-2048)<16; }
function caveDensity(x,z,seed){ return noise(x*0.1,z*0.1,seed)>0.8; }

function drawMap(){
  const seed=parseInt(document.getElementById('seed').value);
  const px=parseInt(document.getElementById('playerX').value);
  const pz=parseInt(document.getElementById('playerZ').value);
  const range=parseInt(document.getElementById('range').value);
  const showTerrain=document.getElementById('showTerrain').checked;
  const heightShading=document.getElementById('heightShading').checked;
  const showSlime=document.getElementById('showSlime').checked;
  const showStructures=document.getElementById('showStructures').checked;
  const showCaves=document.getElementById('showCaves').checked;
  const showGrid=document.getElementById('showGrid').checked;

  const size=range*2;
  const img=ctx.createImageData(size,size);
  let i=0;
  for(let z=0;z<size;z++){
    for(let x=0;x<size;x++){
      const bx=px-range+x+offsetX, bz=pz-range+z+offsetZ;
      let rgb=[200,200,200];
      if(showTerrain){
        rgb=biomeColor(bx,bz,seed);
        if(heightShading){
          const elev=noise(bx*0.05,bz*0.05,seed);
          rgb=shadeColor(rgb,elev,true);
        }
      }
      if(showCaves && caveDensity(bx,bz,seed)) rgb=[100,100,100];
      if(showSlime && isSlimeChunk(seed,bx,bz)) rgb=[0,255,0];
      img.data[i++]=rgb[0];
      img.data[i++]=rgb[1];
      img.data[i++]=rgb[2];
      img.data[i++]=255;
    }
  }
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const tmp=document.createElement('canvas');
  tmp.width=size; tmp.height=size;
  tmp.getContext('2d').putImageData(img,0,0);
  const drawSize=canvas.width*zoom;
  ctx.drawImage(tmp,0,0,size,size,(canvas.width-drawSize)/2,(canvas.height-drawSize)/2,drawSize,drawSize);

  // Structures overlay
  if (showStructures) {
    const drawSize = canvas.width * zoom;
    const startX = (canvas.width - drawSize) / 2;
    const startZ = (canvas.height - drawSize) / 2;

    // Visible world bounds (in blocks)
    const worldMinX = px - range + offsetX;
    const worldMinZ = pz - range + offsetZ;
    const worldMaxX = px + range + offsetX;
    const worldMaxZ = pz + range + offsetZ;

    // Chunk-aligned sampling to check for structures
    ctx.textBaseline = "top";
    ctx.font = `${Math.max(12, 10 * zoom)}px sans-serif`;
    ctx.fillStyle = "#000";

    for (let bz = worldMinZ; bz <= worldMaxZ; bz += 16) {
      for (let bx = worldMinX; bx <= worldMaxX; bx += 16) {
        // Convert world block to screen position inside the zoomed/centered image
        const localX = bx - worldMinX; // 0..size-1
        const localZ = bz - worldMinZ; // 0..size-1
        const sx = startX + localX * zoom;
        const sz = startZ + localZ * zoom;

        // Skip if outside the drawn image
        if (sx < startX || sz < startZ || sx > startX + drawSize || sz > startZ + drawSize) continue;

        // Draw icons
        if (isVillage(bx, bz)) ctx.fillText("üè†", sx, sz);
        if (isTemple(bx, bz))  ctx.fillText("‚õ©Ô∏è", sx, sz);
        if (isStronghold(bx, bz)) ctx.fillText("‚öîÔ∏è", sx, sz);
      }
    }
  }
  // --- Grid overlay ---
  if (showGrid) {
    ctx.strokeStyle = "rgba(0,0,0,0.2)";
    const step = 16 * zoom;
    for (let gx = (canvas.width - drawSize) / 2; gx < canvas.width - (canvas.width - drawSize) / 2; gx += step) {
      ctx.beginPath();
      ctx.moveTo(gx, (canvas.height - drawSize) / 2);
      ctx.lineTo(gx, canvas.height - (canvas.height - drawSize) / 2);
      ctx.stroke();
    }
    for (let gz = (canvas.height - drawSize) / 2; gz < canvas.height - (canvas.height - drawSize) / 2; gz += step) {
      ctx.beginPath();
      ctx.moveTo((canvas.width - drawSize) / 2, gz);
      ctx.lineTo(canvas.width - (canvas.width - drawSize) / 2, gz);
      ctx.stroke();
    }
  }

  // --- Player marker ---
  ctx.fillStyle = "#ff0000";
  ctx.beginPath();
  ctx.arc(canvas.width / 2, canvas.height / 2, 5, 0, Math.PI * 2);
  ctx.fill();
}

// --- Zoom handling ---
canvas.addEventListener("wheel", e => {
  e.preventDefault();
  const prevZoom = zoom;
  zoom *= e.deltaY < 0 ? 1.1 : 0.9;
  zoom = Math.max(0.25, Math.min(8, zoom));
  if (Math.abs(prevZoom - zoom) > 0.001) drawMap();
}, { passive: false });

// --- Panning (drag to move) ---
canvas.addEventListener("mousedown", e => {
  dragging = true;
  dragStartX = e.clientX;
  dragStartY = e.clientY;
  canvas.style.cursor = "grabbing";
});
canvas.addEventListener("mouseup", () => { dragging = false; canvas.style.cursor = "grab"; });
canvas.addEventListener("mouseleave", () => { dragging = false; canvas.style.cursor = "grab"; });
canvas.addEventListener("mousemove", e => {
  if (dragging) {
    const dx = e.clientX - dragStartX;
    const dz = e.clientY - dragStartY;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    offsetX -= Math.round(dx / zoom);
    offsetZ -= Math.round(dz / zoom);
    drawMap();
  }
});

// --- Tooltips on hover ---
canvas.addEventListener("mousemove", e => {
  if (dragging) { tooltip.style.display = "none"; return; }
  const seed = parseInt(document.getElementById('seed').value);
  const px = parseInt(document.getElementById('playerX').value);
  const pz = parseInt(document.getElementById('playerZ').value);
  const range = parseInt(document.getElementById('range').value);
  const size = range * 2;
  const drawSize = canvas.width * zoom;
  const startX = (canvas.width - drawSize) / 2;
  const startZ = (canvas.height - drawSize) / 2;
  const relX = (e.offsetX - startX) / zoom;
  const relZ = (e.offsetY - startZ) / zoom;
  if (relX < 0 || relZ < 0 || relX >= size || relZ >= size) {
    tooltip.style.display = "none"; return;
  }
  const bx = px - range + Math.floor(relX) + offsetX;
  const bz = pz - range + Math.floor(relZ) + offsetZ;
  let info = `Block (${bx}, ${bz})`;
  if (isSlimeChunk(seed, bx, bz)) info += " ‚Ä¢ Slime";
  if (isVillage(bx, bz)) info += " ‚Ä¢ Village";
  if (isTemple(bx, bz)) info += " ‚Ä¢ Temple";
  if (isStronghold(bx, bz)) info += " ‚Ä¢ Stronghold";
  if (caveDensity(bx, bz, seed)) info += " ‚Ä¢ Cave";
  tooltip.textContent = info;
  tooltip.style.left = (e.pageX + 12) + "px";
  tooltip.style.top = (e.pageY + 12) + "px";
  tooltip.style.display = "block";
});
canvas.addEventListener("mouseout", () => tooltip.style.display = "none");

// --- Export PNG ---
function exportMap() {
  const link = document.createElement('a');
  link.download = 'minecraft_map.png';
  link.href = canvas.toDataURL('image/png');
  link.click();
}

// --- Init ---
window.onload = () => {
  drawMap();
};
</script>
</body>
</html>
